<!DOCTYPE html>
<!--
                                                      _
__   ___ __ ___   __ _  __ _  __ _ _ __ ___   ___  __| | _____   __
\ \ / / '_ ` _ \ / _` |/ _` |/ _` | '_ ` _ \ / _ \/ _` |/ _ \ \ / /
 \ V /| | | | | | (_| | (_| | (_| | | | | | |  __/ (_| | (_) \ V /
  \_/ |_| |_| |_|\__,_|\__, |\__,_|_| |_| |_|\___|\__,_|\___/ \_/
                       |___/
                                     Yet another software developer
-->
<html>
    <head>
        <title>vmagamedov - Интернационализация приложений</title>
        <meta charset="utf-8">
        <meta name="description" content="">
        <meta name="author" content="" />
        <link rel="shortcut icon" href="/static/favicon.gif?ver=1">
        <link rel="stylesheet" type="text/css" href="../../../static/css/reset.css">
        <link rel="stylesheet" type="text/css" href="../../../static/fonts/fonts.css">
        <link rel="stylesheet" type="text/css" href="../../../static/css/styles.css">
        <link rel="stylesheet" type="text/css" href="../../../static/css/pygments.css">
        <!--<script src="http://yui.yahooapis.com/3.2.0/build/yui/yui-min.js"></script>-->
        <!--<script type="text/javascript" src="/static/js/..."></script>-->
        <link rel="openid.server" href="http://openid.yandex.ru/server/" />
        <link rel="openid2.provider" href="http://openid.yandex.ru/server/" />
        <link rel="openid.delegate" href="http://openid.yandex.ru/vmagamedov/" />
        <link rel="openid2.local_id" href="http://openid.yandex.ru/vmagamedov/" />
    </head>
    <body>
        <div id="wrapper">
            <div id="header">
                <h3><a href="/">~<span>v</span>magamedov</a></h3>
                <p>Yet another software developer</p>
                <div id="nav">
                    <ul>
                        <li><a href="http://www.linkedin.com/in/vmagamedov" target="_blank">LinkedIn</a></li>
                        <li><a href="http://vmagamedov.moikrug.ru/" target="_blank">МойКруг</a></li>
                        <li><a href="http://twitter.com/vmagamedov" target="_blank">Twitter</a></li>
                        <li><a href="https://bitbucket.org/vmagamedov" target="_blank">Bitbucket</a></li>
                    </ul>
                </div>
            </div>
            <div id="content">
                
                    <div id="main">
                        <div class="post">
                            <div class="side">
                                
<sup>new</sup> <a href="" title="Интернационализация приложений">i18n py</a><br/>
                            </div>
                            <div class="title">
                                <h1>Интернационализация приложений <sup>beta</sup></h1>
                                <script type="text/javascript" src="//yandex.st/share/share.js" charset="utf-8"></script>
                                <div class="yashare-auto-init" data-yashareL10n="ru" data-yashareType="icon" data-yashareQuickServices="facebook,twitter"></div>
                                <div class="clear"></div>
                            </div>
                            <div class="body">
    <p>Как обычно происходит работа по переводу приложения? В сети есть много
документов, описывающих этот процесс, и повторять их не хочется, поэтому
перейдём сразу к самому интересному.</p>
<dl class="docutils">
<dt>Напомню лишь, что обычно перевод происходит в несколько этапов:</dt>
<dd><ul class="first last simple">
<li>извлечение строк для перевода из исходных текстов программы;</li>
<li>собственно сам перевод этих строк на необходимые языки;</li>
<li>компилирование переводов в удобоваримый для программы вид.</li>
</ul>
</dd>
</dl>
<div class="section" id="id1">
<h2>Код программ</h2>
<p>Первоначальной задачей для нас является написание исходных текстов программы
с поддержкой интернационализации. Для этих целей существует библиотека
<a class="reference external" href="http://docs.python.org/library/gettext.html">gettext</a>. Её функционала не всегда хватает и не всегда он подходит под
специфику проекта, поэтому существует огромное количество обёрток вокруг
этой библиотеки. Сразу скажу, что и нам её функционала не хватит.</p>
<p>Какие у нас будут требования? Первое требование - это часто меняющийся
контекст приложения (язык пользователя). Второе требование - проект состоит
из множества компонентов, для каждого из которых существуют собственные
переводы (различные домены переводов).</p>
<p>К чему эти требования? А к тому, что мало кто о них заботится, что и
послужило причиной написания этой статьи.</p>
<p>Начнём с того, что мы имеем. Чаще всего, для перевода строк используются
функции <cite>gettext</cite> и <cite>ngettext</cite>, и ещё их аналоги <cite>ugettext</cite> и <cite>ungettext</cite> для
работы с юникодом. Зачем иметь весь этот зоопарк, если можно обойтись одной
функцией вместо двух и работать только с юникодом. В итоге из 4-х функций
у нас осталась одна, назовём её <cite>tr</cite> - имя короткое и понятное, вот её
сигнатура:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">tr</span><span class="p">(</span><span class="n">single</span><span class="p">,</span> <span class="n">plural</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translates unicode strings&quot;&quot;&quot;</span>
</pre></div>
<p>Во многих проектах используется практика объединения всех переводов в один
каталог, и это противоречит нашему второму требованию. Тут возникает
проблема с тем, что если есть две одинаковые строки в двух разных участках
программы, то перевод для них обеих будет одинаковым, не смотря на то, что
по смыслу и контексту правильнее было бы иметь два разных перевода. Чтобы
решить эту проблему, мы создали специальный класс, который осуществляет
перевод только для одного конкретного домена переводов. Он выглядит примерно
вот так:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Translations</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Translations catalog for specific domain&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single</span><span class="p">,</span> <span class="n">plural</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
<p>Как видно, экземпляр класса <cite>Translations</cite> можно использовать точно так же,
как и функцию <cite>tr</cite>, но при этом мы привязываемся к определённому домену и
конфликтов между различными доменами быть не может.</p>
</div>
<div class="section" id="id2">
<h2>Извлечение</h2>
<p>Для извлечения строк обычно используются специальные утилиты, например
<a class="reference external" href="http://www.gnu.org/software/hello/manual/gettext/xgettext-Invocation.html">xgettext</a> или <a class="reference external" href="http://babel.edgewall.org/wiki/Documentation/cmdline.html">pybabel</a>. Однако в чистом виде они нам не подойдут.
Во-первых, они уж слишком низкоуровневые, для них часто приходится писать
скрипты, чтобы автоматизировать их выполнение. Во-вторых, они не смогут
корректно извлечь строки с переводами, если мы вместо функций <cite>ugettext</cite> и
<cite>ungettext</cite> будем использовать нашу функцию <cite>tr</cite>, они на это не были
рассчитаны.</p>
<p>Решением этой проблемы может стать написание собственной утилиты, но к
счастью у нас есть возможность написать специальную надстройку над
виблиотекой <a class="reference external" href="http://babel.edgewall.org/">Babel</a>, где уже реализована основная часть нужного нам
функционала.</p>
<p>Какие у нас требования? Во многих проектах, опять таки, сами переводы и их
скомпилированные версии хранятся вместе в папке локалей, и в этом же виде
они хранятся в репозитории. Мне кажется, было бы более уместно хранить их
отдельно, иметь отдельно папку с переводами <cite>translations</cite> и отдельно
папку с данными локалей <cite>locale</cite>, причём последнюю не надо хранить
в репозитории, т.к. её всегда можно сгенерировать из файлов с переводами.
В этом и заключаются все наши требования.</p>
<p>В плане реализации, очень удобным оказалось создание специальной команды для
скрипта <cite>setup.py</cite>. Это также помогло максимально автоматизировать работу по
извлечению строк из исходных кодов.</p>
<p>Вот как это выглядит:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">distutils.dist</span> <span class="kn">import</span> <span class="n">Distribution</span>

<span class="o">...</span>

<span class="k">class</span> <span class="nc">Dist</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
    <span class="n">translations</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;foo&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">&#39;locales&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;en&#39;</span><span class="p">,</span> <span class="s">&#39;ru&#39;</span><span class="p">),</span>
            <span class="s">&#39;template&#39;</span><span class="p">:</span> <span class="s">&#39;translations/foo/foo.pot&#39;</span><span class="p">,</span>
            <span class="s">&#39;extractors&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s">&#39;src/foo&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;**.py&#39;</span><span class="p">,</span> <span class="s">&#39;py&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">}</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">distclass</span> <span class="o">=</span> <span class="n">Dist</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
<p>Тут видно, что вся информация, необходимая для извлечения строк, описывается
в скрипте <cite>setup.py</cite> в виде специальной структуры данных <cite>translations</cite>. В
этой структуре описываются части, на которые поделён проект. В нашем примере
проект состоит из одной части <cite>foo</cite>, но их может быть сколько угодно.</p>
<p>После того, как проект будет правильно настроен, можно перейти к процедуре
извлечения строк.</p>
<p>В материалах к этой статье идёт несколько скриптов, в которых содержатся
команды для <cite>setup.py</cite>, как их правильно подключить описано в документации к
<a class="reference external" href="http://docs.python.org/library/distutils.html">distutils</a>.</p>
<p>Для извлечения строк следует воспользоваться командой:</p>
<pre class="literal-block">
python setup.py extract_messages --part foo
</pre>
<p>Тут параметр <cite>part</cite> выбирает часть проекта, у нас это <cite>foo</cite>. После
выполнения данной команды, в директории с переводами <cite>translations</cite>
появится файл <cite>translations/foo/foo.pot</cite> - шаблон файлов с переводами. Как
видно, домен перевода указывается в имени шаблона (в скрипте <cite>setup.py</cite>) и
он может отличаться от названия части проекта.</p>
<p>Для создания или обновления переводов, следует воспользоваться командой:</p>
<pre class="literal-block">
python setup.py update_catalog --part foo
</pre>
<p>После выполнения этой команды, у нас появятся файлы с переводами для нужных
нам языков. Они будут находиться рядом с шаблоном переводов <cite>foo.pot</cite> и
будут называться <cite>foo-en.po</cite> и <cite>foo-ru.po</cite>. Эта же команда служит и для
обновления файлов с переводами.</p>
<p>После того, как строки были переведены в файлах с переводами, следует
выполнить команду:</p>
<pre class="literal-block">
python setup.py compile_catalog --part foo --directory locale
</pre>
<p>Параметр <cite>directory</cite> указывает на директорию с локалью, куда будут помещены
скомпилированные файлы переводов:</p>
<blockquote>
<ul class="simple">
<li><cite>locale/en/LC_MESSAGES/foo.mo</cite></li>
<li><cite>locale/ru/LC_MESSAGES/foo.mo</cite></li>
</ul>
</blockquote>
<p>Вот собственно и весь процесс перевода:) В результате у нас сами переводы
хранятся отдельно от данных с локалями и всё это подробно может быть
сконфигурировано и автоматизировано для отдельных частей проекта.</p>
<p>В качестве примера Вам предлагается посмотреть на <a class="reference external" href="http://hg.magamedov.com/i18n_py/">тестовый проект</a>. В нём
не до конца реализован механизм перевода строк во время выполнения
программы. Причиной этому является то, что у каждого проекта/фреймворка
этот функционал реализован по своему, поэтому тут нет универсального
решения.</p>
</div>

    <script>
    var idcomments_acct = '8049abdc3f320e75fa895cb52765eb85';
    var idcomments_post_id;
    var idcomments_post_url;
    </script>
    <span id="IDCommentsPostTitle" style="display:none"></span>
    <script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
</div>
                        </div>
                    </div>
                
            </div>
            <div id="footer">
                
                    Copyright &copy; 2011 Vladimir Magamedov,
                    powered by <a href="http://pypi.python.org/pypi/cyrax" target="_blank">Cyrax</a>
                
            </div>
        </div>
        <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6339170-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
  })();
</script>
<!-- Yandex.Metrika -->
<script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script>
<div style="display:none;"><script type="text/javascript">
try { var yaCounter1296707 = new Ya.Metrika(1296707); } catch(e){}
</script></div>
<noscript><div style="position:absolute"><img src="//mc.yandex.ru/watch/1296707" alt="" /></div></noscript>
<!-- /Yandex.Metrika -->
        
    </body>
</html>